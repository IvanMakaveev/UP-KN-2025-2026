# За в час


## Задачи

**Note:** Във всички задачи трябва да използвате динамична памет и да заделята точно толкова памет, колкото ви трябва!

**Задача 1:** Напишете функция, която приема като параметър два едномерни сортирани целочислени масива с елементи от тип int и връща като резултат трети масив
(който съдържа всички елементи на двата масива и само тях), който също е сортиран.
Предполага се, че входните масиви са сортирани преди да се извика написаната от вас функция.

**Задача 2:** Напишете функция, която приема масив от цели числа и цяло число и елемент на масива. <br />
Функцията да преподрежда елементите, така че всички по-малки елементи от подадения да са в ляво от него, а всички по-големи - в дясно. <br />
(Забележка: Задачата да се реши с помощта на допълнителен масив - същестува и решение без допълнителна памет (Hoare's partition, Lomuto partition и други), но то не се изисква) <br />

**Пример:**

Вход:
```c++
[1, 5, 6, 3, 0, -1, 2, 9, 7]    3
```
Изход: 
```c++
[1, 0, 2, -1, 3, 6, 5, 9, 7]
```

**Задача 3:** Да се напише функция, която приема стринг **text** и символ **s** и връща матрица, за която е заделено точно количество памет, която съдържа всички думи от **text**, разделени с **s**.

**Пример:**

Вход:
```c++
Hello:my:name:is
:
```
Изход:
```c++
Hello
my
name
is
```

**Задача 4:** Напишете функция, която приема масив и връща масив от масиви, на който елементите му са всички непразни подмасиви на дадения.

**Пример:**

Вход:
```c++
[1, 2, 3]
```
Изход: 
```c++
[1], [2], [3], [1, 2], [2, 3], [1, 3], [1, 2, 3]
```

**Задача 5:** Напишете функции `void insertAt(int*& arr, size_t length, int index, int element)` и `void removeAt(int*& arr, size_t length, int index)`, които добавят / премахват елемент на дадена позиция в динамичен масив. След операцията подаденият масив да е с точно толкова дължина, колкото е нужна.

**Пример:**

```c++
[ 7, 12, 36, 32, 17 ]
```

```c++
insertAt 4 86 // => [ 7, 12, 36, 32, 86, 17 ]
removeAt 1 // => [ 7, 36, 32, 86, 17 ]
```

**Задача 6:** Да се дефинира функция `size_t* sortLex(size_t* nums, size_t N)`, която получава като аргументи положителното число N и масив nums, съдържащ N на брой цели неотрицателни числа, и ги сортира във възходящ ред относно лексикографската наредба 

*Уточнение: 123 е преди 9 по лексикографската наредба*

**Пример:**

```c++
6
[ 13, 14, 7, 2018, 9, 0 ]
```

```c++
[ 0, 13, 14, 2018, 7, 9 ]
```


## Матрици

**Задача 1:** Да се напише функция, която приема матрица и връща транспонираната матрица, за която е заделено точно количество памет.

**Пример:**

Вход:
```c++
1 3 
4 6
7 9
```
Изход:
```c++
1 4 7
3 6 9
```

**Задача 3:** Да се напише функция, която намира броя на отрицателните елементи във всеки ред на двумерен масив.

**Пример:**

```c++
3 4
5  -4  -3  8
2  4  3 -8
1  6  0  8
```

```c++
[ 2, 1, 0 ]
```

**Задача 2:** Напишете програма, която приема 2 матрици с произволен размер от конзолата от конзолата(2 x 2D arrays). Напишете функция, която сравнява 2-те матрици елемент по елемент и връща true, ако са еднакви(аналогично false ако не са).

**Задача 5:** Напишете програма, която приема от стандартния вход число N. След това се прочитат N реда и всеки ред започва с число M, което е дължината на реда. <br />
Да се напие функция, която обработва подадената матрица по следния начин:
   - Връща се нова матрица, за което е заделена точна големина.
   - Първият ред е конкатенацията на последния ред с първия ред на подадената матрица.
   - Вторият ред е конкатенацията на предпоследния ред с втория ред на подадената матрица и тн.


## Въпроси
- Каква е разликата между
   - *new int(4)*
   - *new int[4]*
- Колко памет се използва от следния израз
   - **int* ptr = new int(4)**
- Как изглежда матрица NxM с динамична памет в паметта?
   - Кое се намира на stack-a и кое на heap-a? 
